<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>X-Ray Scan</title>
    <link rel="stylesheet" as="style" crossorigin
        href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/variable/pretendardvariable.min.css" />
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #0a0a0a;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Pretendard Variable', Pretendard, -apple-system, BlinkMacSystemFont, sans-serif;
        }

        .container {
            position: relative;
            width: 400px;
            height: 500px;
            cursor: pointer;
            overflow: hidden;
            border-radius: 8px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.6);
        }

        .base-image {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 1;
        }

        .effect-wrapper {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            clip-path: inset(0 0 100% 0);
            transition: clip-path 2.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .container.scanning .effect-wrapper {
            clip-path: inset(0 0 0% 0);
        }

        .effect-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* 그레인 오버레이 */
        .grain-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 3;
            pointer-events: none;
            opacity: 0;
            transition: opacity 1s ease 2s;
            mix-blend-mode: overlay;
        }

        .container.scanning .grain-overlay {
            opacity: 0.25;
        }

        .instruction {
            position: absolute;
            bottom: 12px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.4);
            font-size: 13px;
            letter-spacing: 1px;
            z-index: 10;
            white-space: nowrap;
        }
    </style>
</head>

<body>

    <div class="container" id="scanContainer">
        <img src="xrlay.png" alt="Base" class="base-image" id="baseImg">

        <div class="effect-wrapper">
            <canvas class="effect-canvas" id="thermalCanvas"></canvas>
        </div>

        <canvas class="grain-overlay" id="grainCanvas"></canvas>
        <div class="instruction">사진을 클릭하세요</div>
    </div>

    <script>
        const container = document.getElementById('scanContainer');
        const baseImg = document.getElementById('baseImg');
        const thermalCanvas = document.getElementById('thermalCanvas');
        const grainCanvas = document.getElementById('grainCanvas');
        const tCtx = thermalCanvas.getContext('2d');
        const gCtx = grainCanvas.getContext('2d');

        let isScanning = false;
        let animFrame = null;
        let phase = 0;
        let warpAmount = 0;
        let targetWarp = 0;

        // --- X-Ray Color LUT ---
        // 검정 → 딥다크블루 → 인디고 → 시안 → 밝은시안 → 흰색
        // + 밝은부분에 약간의 따뜻한 톤 (뼈/고밀도 = 약간 노란기)
        function buildXRayLUT() {
            const stops = [
                { pos: 0, r: 0, g: 0, b: 5 },   // 완전 검정
                { pos: 20, r: 8, g: 2, b: 18 },   // 아주 어두운 적갈색
                { pos: 40, r: 18, g: 5, b: 40 },   // 다크 레드-퍼플
                { pos: 60, r: 15, g: 12, b: 65 },   // 딥 인디고
                { pos: 80, r: 25, g: 25, b: 95 },   // 인디고 블루
                { pos: 100, r: 40, g: 15, b: 110 },   // 따뜻한 바이올렛
                { pos: 120, r: 20, g: 65, b: 145 },   // 미디엄 블루
                { pos: 140, r: 30, g: 125, b: 190 },   // 시안 블루
                { pos: 165, r: 55, g: 185, b: 215 },   // 밝은 시안
                { pos: 190, r: 100, g: 210, b: 225 },   // 라이트 시안
                { pos: 215, r: 160, g: 210, b: 230 },   // 아이시 블루
                { pos: 232, r: 200, g: 195, b: 215 },   // 은은한 라벤더-핑크
                { pos: 242, r: 225, g: 205, b: 210 },   // 소프트 핑크
                { pos: 249, r: 240, g: 225, b: 225 },   // 따뜻한 핑크 화이트
                { pos: 253, r: 250, g: 242, b: 240 },   // 거의 흰색
                { pos: 255, r: 255, g: 255, b: 255 },   // 순백
            ];

            const lut = new Uint8Array(256 * 3);
            for (let i = 0; i < 256; i++) {
                let s0 = stops[0], s1 = stops[stops.length - 1];
                for (let j = 0; j < stops.length - 1; j++) {
                    if (i >= stops[j].pos && i <= stops[j + 1].pos) {
                        s0 = stops[j];
                        s1 = stops[j + 1];
                        break;
                    }
                }
                const t = (s1.pos === s0.pos) ? 0 : (i - s0.pos) / (s1.pos - s0.pos);
                const st = t * t * (3 - 2 * t);
                lut[i * 3] = Math.round(s0.r + (s1.r - s0.r) * st);
                lut[i * 3 + 1] = Math.round(s0.g + (s1.g - s0.g) * st);
                lut[i * 3 + 2] = Math.round(s0.b + (s1.b - s0.b) * st);
            }
            return lut;
        }

        const xrayLUT = buildXRayLUT();

        function initCanvas() {
            const w = 400, h = 500;
            thermalCanvas.width = w;
            thermalCanvas.height = h;
            grainCanvas.width = w;
            grainCanvas.height = h;
        }

        function renderXRay() {
            const w = thermalCanvas.width;
            const h = thermalCanvas.height;

            // 원본을 3번 그려서 RGB 채널 오프셋 (색수차 효과)
            // 먼저 깨끗한 그레이스케일 데이터 얻기
            const offscreen = document.createElement('canvas');
            offscreen.width = w;
            offscreen.height = h;
            const oCtx = offscreen.getContext('2d');
            oCtx.drawImage(baseImg, 0, 0, w, h);
            const srcData = oCtx.getImageData(0, 0, w, h).data;

            // 그레이스케일 + 반전 (X-Ray는 밀도 높은 곳이 밝음)
            const grayMap = new Float32Array(w * h);
            for (let i = 0; i < w * h; i++) {
                const idx = i * 4;
                let gray = srcData[idx] * 0.299 + srcData[idx + 1] * 0.587 + srcData[idx + 2] * 0.114;
                // 반전 (X-Ray 느낌)
                gray = 255 - gray;
                // S-커브 대비
                let c = gray / 255;
                c = c * c * (3 - 2 * c);
                c = c * c * (3 - 2 * c);
                grayMap[i] = c * 255;
            }

            const imageData = tCtx.createImageData(w, h);
            const data = imageData.data;

            // 색수차 오프셋 (R, G, B 채널을 약간씩 다른 위치에서 샘플링)
            const caOffset = 2; // 색수차 픽셀 오프셋

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const i = y * w + x;
                    const pi = i * 4;

                    // 중심 샘플
                    const gray = Math.min(255, Math.max(0, Math.round(grayMap[i])));

                    // R 채널: 약간 왼쪽-위에서 샘플링
                    const rxR = Math.max(0, Math.min(w - 1, x - caOffset));
                    const ryR = Math.max(0, Math.min(h - 1, y - caOffset));
                    const grayR = Math.min(255, Math.max(0, Math.round(grayMap[ryR * w + rxR])));

                    // B 채널: 약간 오른쪽-아래에서 샘플링
                    const rxB = Math.max(0, Math.min(w - 1, x + caOffset));
                    const ryB = Math.max(0, Math.min(h - 1, y + caOffset));
                    const grayB = Math.min(255, Math.max(0, Math.round(grayMap[ryB * w + rxB])));

                    // LUT 적용 (각 채널별 다른 밝기 인덱스 사용)
                    data[pi] = xrayLUT[grayR * 3];
                    data[pi + 1] = xrayLUT[gray * 3 + 1];
                    data[pi + 2] = xrayLUT[grayB * 3 + 2];
                    data[pi + 3] = 255;
                }
            }

            tCtx.putImageData(imageData, 0, 0);

            // 글로우 효과: 밝은 부분에 소프트 블룸
            tCtx.globalCompositeOperation = 'screen';
            tCtx.filter = 'blur(8px) brightness(0.3)';
            tCtx.drawImage(thermalCanvas, 0, 0);
            tCtx.filter = 'none';
            tCtx.globalCompositeOperation = 'source-over';
        }

        function renderGrain() {
            const w = grainCanvas.width;
            const h = grainCanvas.height;
            const imageData = gCtx.createImageData(w, h);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const n = Math.random() * 255;
                data[i] = data[i + 1] = data[i + 2] = n;
                data[i + 3] = 255;
            }
            gCtx.putImageData(imageData, 0, 0);
        }

        // --- SVG displacement (뒤틀기) ---
        const svgNS = 'http://www.w3.org/2000/svg';
        const svg = document.createElementNS(svgNS, 'svg');
        svg.setAttribute('width', '0');
        svg.setAttribute('height', '0');
        svg.style.position = 'absolute';

        const defs = document.createElementNS(svgNS, 'defs');
        const filter = document.createElementNS(svgNS, 'filter');
        filter.setAttribute('id', 'warp-filter');
        filter.setAttribute('x', '-5%');
        filter.setAttribute('y', '-5%');
        filter.setAttribute('width', '110%');
        filter.setAttribute('height', '110%');

        const turb = document.createElementNS(svgNS, 'feTurbulence');
        turb.setAttribute('id', 'turb');
        turb.setAttribute('type', 'fractalNoise');
        turb.setAttribute('baseFrequency', '0.012 0.008');
        turb.setAttribute('numOctaves', '3');
        turb.setAttribute('seed', '5');
        turb.setAttribute('result', 'noise');

        const disp = document.createElementNS(svgNS, 'feDisplacementMap');
        disp.setAttribute('id', 'disp');
        disp.setAttribute('in', 'SourceGraphic');
        disp.setAttribute('in2', 'noise');
        disp.setAttribute('scale', '0');
        disp.setAttribute('xChannelSelector', 'R');
        disp.setAttribute('yChannelSelector', 'G');

        filter.appendChild(turb);
        filter.appendChild(disp);
        defs.appendChild(filter);
        svg.appendChild(defs);
        document.body.appendChild(svg);

        thermalCanvas.style.filter = 'url(#warp-filter)';

        function animateWarp() {
            phase += 0.004;
            warpAmount += (targetWarp - warpAmount) * 0.02;
            disp.setAttribute('scale', warpAmount.toFixed(3));

            const fx = 0.012 + Math.sin(phase * 0.7) * 0.004;
            const fy = 0.008 + Math.cos(phase * 0.4) * 0.003;
            turb.setAttribute('baseFrequency', `${fx.toFixed(5)} ${fy.toFixed(5)}`);

            if (Math.floor(phase * 100) % 8 === 0) renderGrain();

            animFrame = requestAnimationFrame(animateWarp);
        }

        // --- 이벤트 ---
        function onImageReady() {
            initCanvas();
            renderXRay();
            renderGrain();
        }

        baseImg.onload = onImageReady;
        if (baseImg.complete) onImageReady();

        container.addEventListener('click', () => {
            isScanning = !isScanning;
            container.classList.toggle('scanning', isScanning);

            if (isScanning) {
                targetWarp = 4;
                if (!animFrame) animateWarp();
            } else {
                targetWarp = 0;
                const stopCheck = setInterval(() => {
                    if (warpAmount < 0.3) {
                        clearInterval(stopCheck);
                        cancelAnimationFrame(animFrame);
                        animFrame = null;
                        warpAmount = 0;
                        disp.setAttribute('scale', '0');
                    }
                }, 100);
            }
        });
    </script>
</body>

</html>